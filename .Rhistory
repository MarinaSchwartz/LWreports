)
) %>% tab_header(
title = md("**Table 2.** Long-term trophic state data collected monthly by LAKEWATCH volunteers and classification variables color and specific conductance (collected quarterly). Values in bold can be used with Table 1 to evaluate compliance with nutrient criteria."))
#amber figured this out. if we knit using gttable to pdf we get massive issues. this is because GTtable does not support kniting to pdf. if we save as a png file, knitr can knit this png file to the document just fine.
gtsave(table_two, filename = "table_2.png", path = "Lake/output_table")
```{r table 2, out.width= "500px", fig.align='center'}
knitr::include_graphics("Lake/output_table/table_2.png")
knitr::include_graphics("LW Reports Table 1 V.2.png")
knitr::include_graphics("Lake/output_table/table_2.png")
data_1
### Loading and Preparing Data
data_1 = read_xlsx("Lakewatch Base File 10-24-2023.xlsx")
data_1
### Import Libraries ###
###IMPORTING LIBRARIES AND LOADING DATA###
##########################################################################################
#Commenting out this code to add to the for loop file
#importing libraries
library(tidyverse)
library(gt)
library(SciViews)
library(broom)
#broom is just to get values form lm function in easier to reference from
library(glue)
library(ggtext)
#glue and ggtext are for making labels. trying to make labels and get default ggplot functions to correctly parse those labels is a nightmare. ggtext helps by allowing you to use html tags in the labels. glue helps by allowing you to use variables in the labels.
library(readxl)
library(tinytex)
#tinytex::install_tinytex()
#tinytex::tlmgr_update()
#setwd("C:/Users/amber.riner/Documents/LWreports")
### Loading and Preparing Data
data_1 = read_xlsx("Lakewatch Base File 10-24-2023.xlsx")
data_1 <- data_1 %>%
mutate(Lake_County = paste(Lake, County)) %>%
filter(Study == "LW") %>%
filter(County == "Alachua") %>%
filter(`water type` == "Lake" | `water type` == "River/Stream" | `water type` == "Estuary")
head(data_1)
data_2 = read.csv("All_Data.csv")
data_2 = data_2 %>%
mutate(Station = as.character(Station)) %>%
mutate(Lake_County = paste(Lake, County))
head(data_2)
#add na.ignore here to avoid loop error when no data exists for a lake
data_all <- data_1 %>% full_join(data_2, by = c("Lake_County", "Station"))
head(data_all)
#Lakes = unique(data_1$Lake_County)
Lakes = c("Quarry Collier") #run previous line OR this line -EDM
print(Lakes)
n = 1
N = length(Lakes)
### for loop with counter ###
for(l in Lakes){
#subsets data for lake of interest
Lake_1 <- data_1 %>%
filter(Lake_County == l)
Lake_2 <- data_2 %>%
filter(Lake_County == l)
file_name = paste(Lake_2[1], ".pdf")
gmean <- function(x){
xc <- x[!is.na(x)]
xg <- exp(mean(log(xc[xc>0])))
xg <- round(xg)
return(xg)
}
#adding a column using if/else for lake classification
##this code currently has no fallback for if the data is missing.
Lake_2 = Lake_2 %>% mutate(lake_class = ifelse(
gmean(`Color`) > 40, "Colored", ifelse(
gmean(`Color`) <= 40 & gmean(`Cond_uS`) <= 20, "Clear Soft Water","Clear Hard Water")))
#adding a column using if/else for trophic state
Lake_2 = Lake_2 %>% mutate(trophic_state = ifelse(
gmean(CHL) < 3, "Oligotrophic", ifelse(
gmean(CHL) >= 3 & gmean(CHL) < 7, "Mesotrophic", ifelse(
gmean(CHL) >= 7 & gmean(CHL) < 40, "Eutrophic", "Hypereutrophic"))))
if(Lake_1$`water type`[1] == "Lake") {
###change Test.RMD to "LWReport Markdown Code Lake.Rmd"
rmarkdown::render(input = "LWReport Markdown Code Lake.Rmd", output_format = "pdf_document",         # 2. Establish the format
output_file = paste0(l ,"_report.pdf"), # 3. Define the output file name
output_dir = "Lake",                       # 4. Define an output folder/directory
params = list(Lakes = l))  }
if(Lake_1$`water type`[1] == "Estuary") {
rmarkdown::render(input = "LWReport Markdown Code Estuary.Rmd", output_format = "pdf_document",         # 2. Establish the format
output_file = paste0(l ,"_report.pdf"), # 3. Define the output file name
output_dir = "Estuary",                       # 4. Define an output folder/directory
params = list(Lakes = l))  }
if(Lake_1$`water type`[1] == "River/Stream") {
rmarkdown::render(input = "LWReport Markdown Code RiverStream.Rmd", output_format = "pdf_document",         # 2. Establish the format
output_file = paste0(l ,"_report.pdf"), # 3. Define the output file name
output_dir = "RiverStream",                       # 4. Define an output folder/directory
params = list(Lakes = l))  }
########################################################
#counter
print(Lake_2$Lake_County[1])
print(paste(n, "/", N))
n <- n+1
}
### Import Libraries ###
###IMPORTING LIBRARIES AND LOADING DATA###
##########################################################################################
#Commenting out this code to add to the for loop file
#importing libraries
library(tidyverse)
library(gt)
library(SciViews)
library(broom)
#broom is just to get values form lm function in easier to reference from
library(glue)
library(ggtext)
#glue and ggtext are for making labels. trying to make labels and get default ggplot functions to correctly parse those labels is a nightmare. ggtext helps by allowing you to use html tags in the labels. glue helps by allowing you to use variables in the labels.
library(readxl)
library(tinytex)
#tinytex::install_tinytex()
#tinytex::tlmgr_update()
#setwd("C:/Users/amber.riner/Documents/LWreports")
### Loading and Preparing Data
data_1 = read_xlsx("Lakewatch Base File 10-24-2023.xlsx")
data_1 <- data_1 %>%
mutate(Lake_County = paste(Lake, County)) %>%
filter(Study == "LW") %>%
filter(County == "Alachua") %>%
filter(`water type` == "Lake" | `water type` == "River/Stream" | `water type` == "Estuary")
head(data_1)
data_2 = read.csv("All_Data.csv")
data_2 = data_2 %>%
mutate(Station = as.character(Station)) %>%
mutate(Lake_County = paste(Lake, County))
head(data_2)
#add na.ignore here to avoid loop error when no data exists for a lake
data_all <- data_1 %>% full_join(data_2, by = c("Lake_County", "Station"))
head(data_all)
#Lakes = unique(data_1$Lake_County)
Lakes = c("Alto Alachua") #run previous line OR this line -EDM
print(Lakes)
n = 1
N = length(Lakes)
### for loop with counter ###
for(l in Lakes){
#subsets data for lake of interest
Lake_1 <- data_1 %>%
filter(Lake_County == l)
Lake_2 <- data_2 %>%
filter(Lake_County == l)
file_name = paste(Lake_2[1], ".pdf")
gmean <- function(x){
xc <- x[!is.na(x)]
xg <- exp(mean(log(xc[xc>0])))
xg <- round(xg)
return(xg)
}
#adding a column using if/else for lake classification
##this code currently has no fallback for if the data is missing.
Lake_2 = Lake_2 %>% mutate(lake_class = ifelse(
gmean(`Color`) > 40, "Colored", ifelse(
gmean(`Color`) <= 40 & gmean(`Cond_uS`) <= 20, "Clear Soft Water","Clear Hard Water")))
#adding a column using if/else for trophic state
Lake_2 = Lake_2 %>% mutate(trophic_state = ifelse(
gmean(CHL) < 3, "Oligotrophic", ifelse(
gmean(CHL) >= 3 & gmean(CHL) < 7, "Mesotrophic", ifelse(
gmean(CHL) >= 7 & gmean(CHL) < 40, "Eutrophic", "Hypereutrophic"))))
if(Lake_1$`water type`[1] == "Lake") {
###change Test.RMD to "LWReport Markdown Code Lake.Rmd"
rmarkdown::render(input = "LWReport Markdown Code Lake.Rmd", output_format = "pdf_document",         # 2. Establish the format
output_file = paste0(l ,"_report.pdf"), # 3. Define the output file name
output_dir = "Lake",                       # 4. Define an output folder/directory
params = list(Lakes = l))  }
if(Lake_1$`water type`[1] == "Estuary") {
rmarkdown::render(input = "LWReport Markdown Code Estuary.Rmd", output_format = "pdf_document",         # 2. Establish the format
output_file = paste0(l ,"_report.pdf"), # 3. Define the output file name
output_dir = "Estuary",                       # 4. Define an output folder/directory
params = list(Lakes = l))  }
if(Lake_1$`water type`[1] == "River/Stream") {
rmarkdown::render(input = "LWReport Markdown Code RiverStream.Rmd", output_format = "pdf_document",         # 2. Establish the format
output_file = paste0(l ,"_report.pdf"), # 3. Define the output file name
output_dir = "RiverStream",                       # 4. Define an output folder/directory
params = list(Lakes = l))  }
########################################################
#counter
print(Lake_2$Lake_County[1])
print(paste(n, "/", N))
n <- n+1
}
###IMPORTING LIBRARIES AND LOADING DATA###
##########################################################################################
#Commenting out this code to add to the for loop file
#importing libraries
#library(tidyverse)
#library(gt)
#library(SciViews)
#library(broom)
#broom is just to get values form lm function in easier to reference from
#library(glue)
#library(ggtext)
#glue and ggtext are for making labels. trying to make labels and get default ggplot functions to correctly parse those labels is a nightmare. ggtext helps by allowing you to use html tags in the labels. glue helps by allowing you to use variables in the labels.
#library(readxl)
### Loading and Preparing Data
#data_1 = read_xlsx("Lakewatch Base File 10-24-2023.xlsx")
#data_1 <- data_1 %>%
#mutate(Lake_County = paste(Lake, County)) %>%
#filter(Study == "LW") %>%
#filter(`water type` == "Lake")
# head(data_1)
#data_2 = read.csv("All_Data.csv")
#data_2 = data_2 %>%
# mutate(Station = as.character(Station)) %>%
# mutate(Lake_County = paste(Lake, County))
# head(data_2)
# data_all <- data_1 %>% full_join(data_2, by = c("Lake_County", "Station"))
#Lake = data_all %>% filter(Lake_County == "Alice Alachua") #subsetting data for lake alice
##################################################################################
###FUNCTIONS###
#calculates geometric mean
gmean <- function(x){
xc <- x[!is.na(x)]
xg <- exp(mean(log(xc[xc>0])))
xg <- round(xg)
return(xg)
}
#adding a column using if/else for lake classification
##this code currently has no fallback for if the data is missing.
Lake_2 = Lake_2 %>% mutate(lake_class = ifelse(
gmean(`Color`) > 40, "Colored", ifelse(
gmean(`Color`) <= 40 & gmean(`Cond_uS`) <= 20, "Clear Soft Water","Clear Hard Water")))
#adding a column using if/else for trophic state
Lake_2 = Lake_2 %>% mutate(trophic_state = ifelse(
gmean(CHL) < 3, "Oligotrophic", ifelse(
gmean(CHL) >= 3 & gmean(CHL) < 7, "Mesotrophic", ifelse(
gmean(CHL) >= 7 & gmean(CHL) < 40, "Eutrophic", "Hypereutrophic"))))
###IMPORTING LIBRARIES AND LOADING DATA###
##########################################################################################
#Commenting out this code to add to the for loop file
#importing libraries
#library(tidyverse)
#library(gt)
#library(SciViews)
#library(broom)
#broom is just to get values form lm function in easier to reference from
#library(glue)
#library(ggtext)
#glue and ggtext are for making labels. trying to make labels and get default ggplot functions to correctly parse those labels is a nightmare. ggtext helps by allowing you to use html tags in the labels. glue helps by allowing you to use variables in the labels.
#library(readxl)
### Loading and Preparing Data
#data_1 = read_xlsx("Lakewatch Base File 10-24-2023.xlsx")
#data_1 <- data_1 %>%
#mutate(Lake_County = paste(Lake, County)) %>%
#filter(Study == "LW") %>%
#filter(`water type` == "Lake")
# head(data_1)
#data_2 = read.csv("All_Data.csv")
#data_2 = data_2 %>%
# mutate(Station = as.character(Station)) %>%
# mutate(Lake_County = paste(Lake, County))
# head(data_2)
# data_all <- data_1 %>% full_join(data_2, by = c("Lake_County", "Station"))
#Lake = data_all %>% filter(Lake_County == "Alice Alachua") #subsetting data for lake alice
##################################################################################
###FUNCTIONS###
#calculates geometric mean
gmean <- function(x){
xc <- x[!is.na(x)]
xg <- exp(mean(log(xc[xc>0])))
xg <- round(xg)
return(xg)
}
#adding a column using if/else for lake classification
##this code currently has no fallback for if the data is missing.
Lake_2 = Lake_2 %>% mutate(lake_class = ifelse(
gmean(`Color`) > 40, "Colored", ifelse(
gmean(`Color`) <= 40 & gmean(`Cond_uS`) <= 20, "Clear Soft Water","Clear Hard Water")))
#adding a column using if/else for trophic state
Lake_2 = Lake_2 %>% mutate(trophic_state = ifelse(
gmean(CHL) < 3, "Oligotrophic", ifelse(
gmean(CHL) >= 3 & gmean(CHL) < 7, "Mesotrophic", ifelse(
gmean(CHL) >= 7 & gmean(CHL) < 40, "Eutrophic", "Hypereutrophic"))))
### Ambers code from table 2
#geometric means by year
byyr <- Lake_2 %>%
mutate(SECCHI_m = SECCHI_ft*.3) %>%
group_by(Year) %>%
summarize(gmean(TP), gmean(TN), gmean(CHL), gmean(SECCHI_ft), gmean(SECCHI_m), gmean(Color), gmean(Cond_uS))
#minimum annual geometric means
mins = c("Minimum Annual Geometric Mean", min(byyr$`gmean(TP)`), min(byyr$`gmean(TN)`), min(byyr$`gmean(CHL)`), min(byyr$`gmean(SECCHI_ft)`), min(byyr$`gmean(SECCHI_m)`), min(byyr$`gmean(Color)`), min(byyr$`gmean(Cond_uS)`), Lake_2$lake_class[1])
#maximum annual geometric means
maxs = c("Maximum Annual Geometric Mean", max(byyr$`gmean(TP)`), max(byyr$`gmean(TN)`), max(byyr$`gmean(CHL)`), max(byyr$`gmean(SECCHI_ft)`), max(byyr$`gmean(SECCHI_m)`), max(byyr$`gmean(Color)`), max(byyr$`gmean(Cond_uS)`), " ")
#grand geometric means
ggmean = c("Grand Geometric Mean", gmean(byyr$`gmean(TP)`), gmean(byyr$`gmean(TN)`), gmean(byyr$`gmean(CHL)`), gmean(byyr$`gmean(SECCHI_ft)`), gmean(.3*byyr$`gmean(SECCHI_ft)`), gmean(byyr$`gmean(Color)`), gmean(byyr$`gmean(Cond_uS)`), "NA")
####End Ambers Code####
### TABLE 3 CODE ### MS EDITS 4-10
#geometric means by year
byyr <- Lake_2 %>%
mutate(SECCHI_m = SECCHI_ft*.3) %>%
group_by(Year) %>%
summarize(gmean(TP), gmean(TN), gmean(CHL), gmean(SECCHI_ft), gmean(SECCHI_m), gmean(Color), gmean(Cond_uS))
#total geometric means full data
ggtp <- gmean(byyr$`gmean(TP)`)
ggtn <- gmean(byyr$`gmean(TN)`)
ggchl <- gmean(byyr$`gmean(CHL)`)
ggsec <- (byyr$`gmean(SECCHI_ft)`)
#calculate TSI
tsi_sd <- 60 -14.41*ln(ggsec)
tsi_chl <- 9.81* ln(ggchl) + 30.6
tsi_tp <- 14.42* ln(ggtp) + 4.15
tsi <- mean(tsi_sd, tsi_chl, tsi_tp)
#define variables
cnty <- Lake_2$County[1] #county
name <- Lake_2$Lake[1] #name
pr <- paste(min(Lake_2$Year), " to ", max(Lake_2$Year)) #period of record
lts <- ifelse(tsi < 40 , "Oligotrophic",
(ifelse(tsi < 50 , "Mesotrophic",
(ifelse(tsi < 70, "Eutrophic", "Hypereutrophic")))))  #lake trophic status
tpz <- Lake_1$`TP Zone`[1] #tp zone
gtp <- paste(ggtp, "(", min(byyr$`gmean(TP)`), " to ", max(byyr$`gmean(TP)`) , ")" ) #grand total phosphorous
tnz <- Lake_1$`TN Zone`[1]
gtn <- paste(ggtn, "(", min(byyr$`gmean(TN)`), " to ", max(byyr$`gmean(TN)`), ")") #grand tn geomean
gnis <- Lake_1$GNIS_ID[1]
lat <- round(Lake_1$Latitude[1], 4)
long <- round(Lake_1$Longitude[1], 4)
wbt <- Lake_1$`water type`[1]
sa <- paste(Lake_1$`SA (hectare)`[1], "ha, ", Lake_1$`SA (acres)`[1], "acres")
### IF Statements (Before I had access to the base file).  Will possible use later
# tpz <- ifelse(ggtp >= 355, "TP6",
#               (ifelse(ggtp >= 252, "TP5",
#                (ifelse(ggtp >= 93, "TP4",
#                 (ifelse(ggtp >= 45, "TP3",
#                  (ifelse(ggtp >= 21, "TP2","TP1"))))))))) #tp zone
# tnz <- ifelse(ggtn >= 2701, "TN6",
#               (ifelse(ggtn >= 1369, "TN5",
#                (ifelse(ggtn >= 1087, "TN4",
#                 (ifelse(ggtn >= 642, "TN3",
#                  (ifelse(ggtn >= 450, "TN2","TN1"))))))))) #tn zone
#add values to array
rowval <- c(cnty, name, gnis, lat, long, wbt, sa, pr, lts, tpz, gtp, tnz, gtn )
#add row names to array
rowname <- c("County", "Name", "GNIS Number", "Latitude", "Longitude", "Water Body Type", "Surface Area (ha and acre)", "Period of Record (year)", "Lake Tophic Status (CHL)", "TP Zone", "Grand TP Geometric Mean Concentration (ug/ L, min, and max.)", "TN Zone", "Grand TN Geometric Mean Concentration (ug/ L, min, and max.)")
#make dataframe with rownames and row values
tbl3df <- data.frame(rowname, rowval)
#make gt table
table_three = gt(tbl3df) %>% tab_options(column_labels.hidden = TRUE) %>% fmt_number(
decimals = 4,drop_trailing_zeros = TRUE,
) %>% opt_table_font(
stack = "transitional"
) %>%  tab_style(
style =
cell_text(weight = "bold"),
locations = cells_body(
columns = 2,
rows = 10
)
) %>%  tab_style(
style =
cell_text(weight = "bold"),
locations = cells_body(
columns = 2,
rows = 11
)
) %>%  tab_style(
style =
cell_text(weight = "bold"),
locations = cells_body(
columns = 2,
rows = 12
)
) %>%  tab_style(
style =
cell_text(weight = "bold"),
locations = cells_body(
columns = 2,
rows = 13
)
) %>% tab_header(
title = md("**Table 3.** Base File Data, long-term nutrient grand geometric means and Nutrient Zone classification listing the 90th percentile concentrations in Figure 1. Values in bold can be used for Nutrient Zone comparisons."))
gtsave(table_three, filename = "table_3.png", path = "Lake/output_table")
#geometric means by year
byyr <- Lake_2 %>%
mutate(SECCHI_m = SECCHI_ft*.3) %>%
group_by(Year) %>%
summarize(gmean(TP), gmean(TN), gmean(CHL), gmean(SECCHI_ft), gmean(SECCHI_m), gmean(Color), gmean(Cond_uS))
#minimum annual geometric means
mins = c("Minimum Annual Geometric Mean", min(byyr$`gmean(TP)`), min(byyr$`gmean(TN)`), min(byyr$`gmean(CHL)`), min(byyr$`gmean(SECCHI_ft)`), min(byyr$`gmean(SECCHI_m)`), min(byyr$`gmean(Color)`), min(byyr$`gmean(Cond_uS)`), Lake_2$lake_class[1])
#maximum annual geometric means
maxs = c("Maximum Annual Geometric Mean", max(byyr$`gmean(TP)`), max(byyr$`gmean(TN)`), max(byyr$`gmean(CHL)`), max(byyr$`gmean(SECCHI_ft)`), max(byyr$`gmean(SECCHI_m)`), max(byyr$`gmean(Color)`), max(byyr$`gmean(Cond_uS)`), " ")
#grand geometric means
ggmean = c("Grand Geometric Mean", gmean(byyr$`gmean(TP)`), gmean(byyr$`gmean(TN)`), gmean(byyr$`gmean(CHL)`), gmean(byyr$`gmean(SECCHI_ft)`), gmean(.3*byyr$`gmean(SECCHI_ft)`), gmean(byyr$`gmean(Color)`), gmean(byyr$`gmean(Cond_uS)`), "NA")
#year counts
n = c("n", length(byyr$`gmean(TP)`[is.na(byyr$`gmean(TP)`)== FALSE]), length(byyr$`gmean(TN)`[is.na(byyr$`gmean(TN)`) == FALSE]), length(byyr$`gmean(CHL)`[ is.na(byyr$`gmean(CHL)`) == FALSE]), length(byyr$`gmean(SECCHI_ft)`[ is.na(byyr$`gmean(SECCHI_ft)`) == FALSE]), length(byyr$`gmean(SECCHI_ft)`[is.na(byyr$`gmean(SECCHI_ft)`) == FALSE]), length(byyr$`gmean(Color)`[ is.na(byyr$`gmean(Color)`) == FALSE]), length(byyr$`gmean(Cond_uS)`[is.na(byyr$`gmean(Cond_uS)`) == FALSE]), " " )
#add row names to array
rowname <- c("Parameter", "Total Phosphorus (µg/L)" , "Total Nitrogen (µg/L)" ,  "Chlorophyll- uncorrected (µg/L)" , "Secchi (ft)" , "Secchi (m)" ,  "Color (Pt-Co Units)" , "Specific Conductance (µS/cm@25 C)" ,  "Lake Classification" )
#make dataframe with rownames and row values
tbl2df <- data.frame(rowname, mins, maxs, ggmean, n)
#tbl2df[tbl2df == "NaN"] <- " "
#tbl2df[tbl2df == "NA"] <- " "
#tbl2df[tbl2df == "Inf"] <- " "
table_two <- gt(data = tbl2df) %>%
fmt_number(
columns = c(mins, maxs, ggmean),
decimals = 1) %>%
tab_options(column_labels.hidden = TRUE) %>%
opt_table_font(stack = "transitional")  %>%
tab_style(
style =
cell_text(weight = "bold"),
locations = cells_body(
columns = mins,
rows = 9
)
) %>%  tab_style(
style =
cell_text(weight = "bold"),
locations = cells_body(
columns = ggmean,
rows = 2
)
) %>%  tab_style(
style =
cell_text(weight = "bold"),
locations = cells_body(
columns = ggmean,
rows = 3
)
) %>%  tab_style(
style =
cell_text(weight = "bold"),
locations = cells_body(
columns = ggmean,
rows = 4
)
) %>% tab_header(
title = md("**Table 2.** Long-term trophic state data collected monthly by LAKEWATCH volunteers and classification variables color and specific conductance (collected quarterly). Values in bold can be used with Table 1 to evaluate compliance with nutrient criteria."))
#amber figured this out. if we knit using gttable to pdf we get massive issues. this is because GTtable does not support kniting to pdf. if we save as a png file, knitr can knit this png file to the document just fine.
gtsave(table_two, filename = "table_2.png", path = "Lake/output_table")
knitr::include_graphics("Lake/output_table/table_2.png")
#minimum annual geometric means
mins = c("Minimum Annual Geometric Mean", min(byyr$`gmean(TP)`), min(byyr$`gmean(TN)`), min(byyr$`gmean(CHL)`), min(byyr$`gmean(SECCHI_ft)`), min(byyr$`gmean(SECCHI_m)`), min(byyr$`gmean(Color)`), min(byyr$`gmean(Cond_uS)`), Lake_2$lake_class[1])
print(mins)
min(byyr$`gmean(Color)`)
byyr$Color
byyr$`gmean(Color)`
byyr`gmean(Color)`[is.na(byyr`gmean(Color)`) == FALSE]
byyr$`gmean(Color)`[is.na(byyr`gmean(Color)`) == FALSE]
byyr$`gmean(Color)`[is.na(byyr$`gmean(Color)`) == FALSE]
min(byyr$`gmean(Color)`[is.na(byyr$`gmean(Color)`) == FALSE])
mins = c("Minimum Annual Geometric Mean", min(byyr$`gmean(TP)`[is.na(byyr$`gmean(TP)`)== FALSE]), min(byyr$`gmean(TN)`[is.na(byyr$`gmean(TN)`) == FALSE]), min(byyr$`gmean(CHL)`[ is.na(byyr$`gmean(CHL)`) == FALSE]), min(byyr$`gmean(SECCHI_ft)`[ is.na(byyr$`gmean(SECCHI_ft)`) == FALSE]), min(byyr$`gmean(SECCHI_ft)`[is.na(byyr$`gmean(SECCHI_ft)`) == FALSE]), min(byyr$`gmean(Color)`[ is.na(byyr$`gmean(Color)`) == FALSE]), min(byyr$`gmean(Cond_uS)`[is.na(byyr$`gmean(Cond_uS)`) == FALSE]), " " )
mins
maxs = c("Maximum Annual Geometric Mean", max(byyr$`gmean(TP)`[is.na(byyr$`gmean(TP)`)== FALSE]), max(byyr$`gmean(TN)`[is.na(byyr$`gmean(TN)`) == FALSE]), max(byyr$`gmean(CHL)`[ is.na(byyr$`gmean(CHL)`) == FALSE]), max(byyr$`gmean(SECCHI_ft)`[ is.na(byyr$`gmean(SECCHI_ft)`) == FALSE]), max(byyr$`gmean(SECCHI_ft)`[is.na(byyr$`gmean(SECCHI_ft)`) == FALSE]), max(byyr$`gmean(Color)`[ is.na(byyr$`gmean(Color)`) == FALSE]), max(byyr$`gmean(Cond_uS)`[is.na(byyr$`gmean(Cond_uS)`) == FALSE]), " " )
maxs
#grand geometric means
ggmean = c("Grand Geometric Mean", gmean(byyr$`gmean(TP)`[is.na(byyr$`gmean(TP)`)== FALSE]), gmean(byyr$`gmean(TN)`[is.na(byyr$`gmean(TN)`) == FALSE]), gmean(byyr$`gmean(CHL)`[ is.na(byyr$`gmean(CHL)`) == FALSE]), gmean(byyr$`gmean(SECCHI_ft)`[ is.na(byyr$`gmean(SECCHI_ft)`) == FALSE]), gmean(byyr$`gmean(SECCHI_ft)`[is.na(byyr$`gmean(SECCHI_ft)`) == FALSE]), gmean(byyr$`gmean(Color)`[ is.na(byyr$`gmean(Color)`) == FALSE]), gmean(byyr$`gmean(Cond_uS)`[is.na(byyr$`gmean(Cond_uS)`) == FALSE]), " " )
#minimum annual geometric means
mins = c("Minimum Annual Geometric Mean", min(byyr$`gmean(TP)`[is.na(byyr$`gmean(TP)`)== FALSE]), min(byyr$`gmean(TN)`[is.na(byyr$`gmean(TN)`) == FALSE]), min(byyr$`gmean(CHL)`[ is.na(byyr$`gmean(CHL)`) == FALSE]), min(byyr$`gmean(SECCHI_ft)`[ is.na(byyr$`gmean(SECCHI_ft)`) == FALSE]), min(byyr$`gmean(SECCHI_ft)`[is.na(byyr$`gmean(SECCHI_ft)`) == FALSE]), min(byyr$`gmean(Color)`[ is.na(byyr$`gmean(Color)`) == FALSE]), min(byyr$`gmean(Cond_uS)`[is.na(byyr$`gmean(Cond_uS)`) == FALSE]), Lake_2$lake_class[1)
#minimum annual geometric means
mins = c("Minimum Annual Geometric Mean", min(byyr$`gmean(TP)`[is.na(byyr$`gmean(TP)`)== FALSE]), min(byyr$`gmean(TN)`[is.na(byyr$`gmean(TN)`) == FALSE]), min(byyr$`gmean(CHL)`[ is.na(byyr$`gmean(CHL)`) == FALSE]), min(byyr$`gmean(SECCHI_ft)`[ is.na(byyr$`gmean(SECCHI_ft)`) == FALSE]), min(byyr$`gmean(SECCHI_ft)`[is.na(byyr$`gmean(SECCHI_ft)`) == FALSE]), min(byyr$`gmean(Color)`[ is.na(byyr$`gmean(Color)`) == FALSE]), min(byyr$`gmean(Cond_uS)`[is.na(byyr$`gmean(Cond_uS)`) == FALSE]), Lake_2$lake_class[1])
#geometric means by year
byyr <- Lake_2 %>%
mutate(SECCHI_m = SECCHI_ft*.3) %>%
group_by(Year) %>%
summarize(gmean(TP), gmean(TN), gmean(CHL), gmean(SECCHI_ft), gmean(SECCHI_m), gmean(Color), gmean(Cond_uS))
#minimum annual geometric means
mins = c("Minimum Annual Geometric Mean", min(byyr$`gmean(TP)`[is.na(byyr$`gmean(TP)`)== FALSE]), min(byyr$`gmean(TN)`[is.na(byyr$`gmean(TN)`) == FALSE]), min(byyr$`gmean(CHL)`[ is.na(byyr$`gmean(CHL)`) == FALSE]), min(byyr$`gmean(SECCHI_ft)`[ is.na(byyr$`gmean(SECCHI_ft)`) == FALSE]), min(byyr$`gmean(SECCHI_ft)`[is.na(byyr$`gmean(SECCHI_ft)`) == FALSE]), min(byyr$`gmean(Color)`[ is.na(byyr$`gmean(Color)`) == FALSE]), min(byyr$`gmean(Cond_uS)`[is.na(byyr$`gmean(Cond_uS)`) == FALSE]), Lake_2$lake_class[1])
min(byyr$`gmean(Color)`[is.na(byyr$`gmean(Color)`) == FALSE])
#maximum annual geometric means
maxs = c("Maximum Annual Geometric Mean", max(byyr$`gmean(TP)`[is.na(byyr$`gmean(TP)`)== FALSE]), max(byyr$`gmean(TN)`[is.na(byyr$`gmean(TN)`) == FALSE]), max(byyr$`gmean(CHL)`[ is.na(byyr$`gmean(CHL)`) == FALSE]), max(byyr$`gmean(SECCHI_ft)`[ is.na(byyr$`gmean(SECCHI_ft)`) == FALSE]), max(byyr$`gmean(SECCHI_ft)`[is.na(byyr$`gmean(SECCHI_ft)`) == FALSE]), max(byyr$`gmean(Color)`[ is.na(byyr$`gmean(Color)`) == FALSE]), max(byyr$`gmean(Cond_uS)`[is.na(byyr$`gmean(Cond_uS)`) == FALSE]), " " )
#grand geometric means
ggmean = c("Grand Geometric Mean", gmean(byyr$`gmean(TP)`[is.na(byyr$`gmean(TP)`)== FALSE]), gmean(byyr$`gmean(TN)`[is.na(byyr$`gmean(TN)`) == FALSE]), gmean(byyr$`gmean(CHL)`[ is.na(byyr$`gmean(CHL)`) == FALSE]), gmean(byyr$`gmean(SECCHI_ft)`[ is.na(byyr$`gmean(SECCHI_ft)`) == FALSE]), gmean(byyr$`gmean(SECCHI_ft)`[is.na(byyr$`gmean(SECCHI_ft)`) == FALSE]), gmean(byyr$`gmean(Color)`[ is.na(byyr$`gmean(Color)`) == FALSE]), gmean(byyr$`gmean(Cond_uS)`[is.na(byyr$`gmean(Cond_uS)`) == FALSE]), " " )
#year counts
n = c("n", length(byyr$`gmean(TP)`[is.na(byyr$`gmean(TP)`)== FALSE]), length(byyr$`gmean(TN)`[is.na(byyr$`gmean(TN)`) == FALSE]), length(byyr$`gmean(CHL)`[ is.na(byyr$`gmean(CHL)`) == FALSE]), length(byyr$`gmean(SECCHI_ft)`[ is.na(byyr$`gmean(SECCHI_ft)`) == FALSE]), length(byyr$`gmean(SECCHI_ft)`[is.na(byyr$`gmean(SECCHI_ft)`) == FALSE]), length(byyr$`gmean(Color)`[ is.na(byyr$`gmean(Color)`) == FALSE]), length(byyr$`gmean(Cond_uS)`[is.na(byyr$`gmean(Cond_uS)`) == FALSE]), " " )
#add row names to array
rowname <- c("Parameter", "Total Phosphorus (µg/L)" , "Total Nitrogen (µg/L)" ,  "Chlorophyll- uncorrected (µg/L)" , "Secchi (ft)" , "Secchi (m)" ,  "Color (Pt-Co Units)" , "Specific Conductance (µS/cm@25 C)" ,  "Lake Classification" )
#make dataframe with rownames and row values
tbl2df <- data.frame(rowname, mins, maxs, ggmean, n)
#tbl2df[tbl2df == "NaN"] <- " "
#tbl2df[tbl2df == "NA"] <- " "
#tbl2df[tbl2df == "Inf"] <- " "
table_two <- gt(data = tbl2df) %>%
fmt_number(
columns = c(mins, maxs, ggmean),
decimals = 1) %>%
tab_options(column_labels.hidden = TRUE) %>%
opt_table_font(stack = "transitional")  %>%
tab_style(
style =
cell_text(weight = "bold"),
locations = cells_body(
columns = mins,
rows = 9
)
) %>%  tab_style(
style =
cell_text(weight = "bold"),
locations = cells_body(
columns = ggmean,
rows = 2
)
) %>%  tab_style(
style =
cell_text(weight = "bold"),
locations = cells_body(
columns = ggmean,
rows = 3
)
) %>%  tab_style(
style =
cell_text(weight = "bold"),
locations = cells_body(
columns = ggmean,
rows = 4
)
) %>% tab_header(
title = md("**Table 2.** Long-term trophic state data collected monthly by LAKEWATCH volunteers and classification variables color and specific conductance (collected quarterly). Values in bold can be used with Table 1 to evaluate compliance with nutrient criteria."))
#amber figured this out. if we knit using gttable to pdf we get massive issues. this is because GTtable does not support kniting to pdf. if we save as a png file, knitr can knit this png file to the document just fine.
gtsave(table_two, filename = "table_2.png", path = "Lake/output_table")
knitr::include_graphics("Lake/output_table/table_2.png")
