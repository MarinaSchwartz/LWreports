mutate(MPRI = (G-R)/ (G+R)) %>%
mutate(CRI = (1/B)-(1/G)) %>%
mutate(EXGR = EXGI - 1.4*R - G)
(data)
#making data in long form
vis <- c("TGI", "VARI", "EXGI", "MGRVI", "RGBVI", "GLI", "MPRI", "CRI", "EXGR")
datlng <- data %>%
pivot_longer(cols = vis, names_to = "VI", values_to = "value")
data = read.csv("All_RUN_12pm_30m_cal.csv", header = T) %>%
rename(WAT = 1) |>
mutate(Rate_Metric = round(oz.A*0.0700531973 , 2)) %>%   #convert oz/a to kg/hectares
mutate(Control = ifelse(Treat == "Untreated Control", "C", "T")) %>%
mutate(Rate_Metric = ifelse(is.na(Rate_Metric), " ", paste(Rate_Metric, "kg/ha"))) %>% #take out NA values and create treatment Names
filter(Treat != "1/2 Fert Control") %>%
mutate(uPhyto = Phyto) %>%
mutate(Phyto = asin(sqrt(Phyto/100))) %>%
#make factors
mutate(Season = as.factor(Season))%>%
mutate(Rate = as.factor(Rate)) %>%
mutate(Treat = as.factor(Treat)) %>%
mutate(WAT = as.factor(WAT)) %>%
mutate(Mode_Action = ifelse(Treat == "Florpyrauxifen-benzyl" | Treat == "2,4-D", "Auxin Mimic", ifelse(Treat == "Penoxsulam" | Treat == "Glyphosate", "Amino Acid Inhibitor", ifelse(Treat == "Diquat" | Treat == "Carfentrazone", "Contact", "Control")))) %>% #add mode of Action Column
mutate(Treat_Name = paste(Treat, Rate_Metric)) %>%
#add VI columns
mutate(TGI = G - .39*R - .61*B) %>%
mutate(VARI = (G - R)/(G+R-B)) %>%
mutate(EXGI = 2*G - R - B) %>%
mutate(MGRVI = (G^2 - R^2)/(G^2+R^2)) %>%
mutate(RGBVI = (G^2 - R*B)/ (G^2+R*B)) %>%
mutate(GLI = (2*G - R - B)/(2*G+R+B)) %>%
mutate(MPRI = (G-R)/ (G+R)) %>%
mutate(CRI = (1/B)-(1/G)) %>%
mutate(EXGR = EXGI - 1.4*R - G)
(data)
#making data in long form
vis <- c("TGI", "VARI", "EXGI", "MGRVI", "RGBVI", "GLI", "MPRI", "CRI", "EXGR")
datlng <- data %>%
pivot_longer(cols = vis, names_to = "VI", values_to = "value")
# Remove data from untreated control. Also, for later, create proportion version of
# phytotoxicity and fix rate levels
set = data |>
filter(Treat != 'Untreated Control') |>
mutate(Sc_Phyto = uPhyto/100,
Rate = factor(Rate, levels = c('L', 'H'),
labels = c('Low', 'High'))) |>
droplevels()
# Use cor function on all the VI columns
sapply(set[, vis], FUN = cor, y = set$uPhyto, method = 'kendall')
null_fit = glmmTMB(Sc_Phyto ~ 1, data = set,
family = ordbeta(link = 'logit'))
AIC(null_fit,
update(null_fit, formula. = Sc_Phyto ~ TGI),
update(null_fit, formula. = Sc_Phyto ~ VARI),
update(null_fit, formula. = Sc_Phyto ~ EXGI),
update(null_fit, formula. = Sc_Phyto ~ MGRVI),
update(null_fit, formula. = Sc_Phyto ~ RGBVI),
update(null_fit, formula. = Sc_Phyto ~ GLI),
update(null_fit, formula. = Sc_Phyto ~ MPRI),
update(null_fit, formula. = Sc_Phyto ~ CRI),   # CRI is still best
update(null_fit, formula. = Sc_Phyto ~ EXGR))
fit = glmmTMB(Sc_Phyto ~ CRI, data = set, family = ordbeta(link = 'logit'))
emm = emmeans(fit, ~ CRI, type = 'response',
at = list(CRI = seq(min(set$CRI), max(set$CRI), diff(range(set$CRI))/100)))
emm |>
as.data.frame() |>
ggplot(aes(x = CRI))+
geom_ribbon(aes(ymin = asymp.LCL, ymax = asymp.UCL), alpha = .25)+
geom_line(aes(y = response))+
geom_point(aes(y = Sc_Phyto), data = set)
fit = glmmTMB(Sc_Phyto ~ CRI/Treat, data = set, family = ordbeta(link = 'logit'))
emm = emmeans(fit, ~ CRI|Treat, type = 'response', cov.keep = T,
at = expand.grid(CRI = seq(min(set$CRI), max(set$CRI), diff(range(set$CRI))/100)))
emm |>
as.data.frame() |>
ggplot(aes(x = CRI, color = Treat, fill = Treat))+
facet_wrap(~ Treat)+
geom_ribbon(aes(ymin = asymp.LCL, ymax = asymp.UCL), alpha = .25, color = NA)+
geom_line(aes(y = response))+
geom_point(aes(y = Sc_Phyto), data = set)
fit = glmmTMB(Sc_Phyto ~ CRI/Treat + (CRI-1|WAT), data = set, family = ordbeta(link = 'logit'))
#| eval: false
ilink = family(fit)$linkinv
X = cbind(1, seq(min(set$CRI), max(set$CRI), diff(range(set$CRI))/100))
beta = fixef(fit)$cond
V = vcov(fit)$cond
VC = X%*%V%*%t(X)
data2 = data |>
mutate(Sc_Phyto = uPhyto/100, #0.5+(uPhyto/100-0.5)*.95,
Rate = factor(Rate, levels = c('L', 'H'),
labels = c('Low', 'High')),
ID = interaction(Treat, Rate, Season, sep = '-')) |>
filter(Treat != 'Untreated Control') |>
droplevels()
fit_spt = glmmTMB(Sc_Phyto ~ Treat*Rate*Season*WAT + (1|ID),
data = data2,
family = ordbeta(link = 'logit'),
control = glmmTMBControl(optCtrl=list(iter.max=1e3,eval.max=1e3)))
res = simulateResiduals(fit) |>
resid(quantileFunction = qnorm, outlierValues = c(-4, 4))
pred = fitted(fit)
resid_auxpanel(res, pred)
joint_tests(fit)
emmeans(fit, ~Treat|WAT:Season, type = 'response') |>
as.data.frame() |>
dplyr::select(WAT, Season, Treat, response) |>
pivot_wider(names_from = 'WAT', values_from = 'response')
emm = emmeans(fit, ~ Treat|Rate:Season, type = 'response')
emm # Note ordering of treats in each rate x season combination
# Define contrast in terms of treatment weights
contr_list = list('Contact - Auxin' = c(-0.5, +0.5, +0.5, -0.5, 0.0, 0.0))
# Estimates and tests are reported as odds ratios
contrast(emm, contr_list)
data3 = data2 |>
filter(WAT == '6') |>
droplevels()
set |>
ggplot(aes(x = Biomass))+
facet_grid(cols = vars(Treat))+
geom_histogram()
library(nlme)
biomass_fit = gls(Biomass ~ Treat*Rate*Season, data = data2,
na.action = na.omit)
resid_auxpanel(resid(biomass_fit, type = 'pearson'), fitted(biomass_fit))
plot(biomass_fit, Treat~resid(.))
AIC(update(biomass_fit, method = 'ML'),
update(biomass_fit, method = 'ML', weights = varIdent(form = ~1|Treat)))
biomass_fit = update(biomass_fit, weights = varIdent(form = ~1|Treat))
emmeans(biomass_fit, ~Treat|Season, mode = 'appx-satterthwaite')
biomass_fit = gls(log(Biomass+10) ~ Treat*Rate*Season, data = data2,
na.action = na.omit, weights = varIdent(form = ~1|Treat))
resid_auxpanel(resid(biomass_fit, type = 'pearson'), fitted(biomass_fit))
emmeans(biomass_fit, ~Treat|Season, type = 'response', bias.adjust = T, mode = 'appx-satterthwaite')
check = glmmTMB(Biomass+10 ~ Treat*Rate*Season, data = data2, family = Gamma(link = 'log'))
res = simulateResiduals(check) |>
resid(quantileFunction = qnorm, outlierValues = c(-5, 5))
pred = fitted(check)
resid_auxpanel(res, pred)
emmeans(check, ~Treat|Season, type = 'response')
fit_spt = glmmTMB(Sc_Phyto ~ Treat*Rate*Season*WAT + (1|ID),
data = data2,
family = ordbeta(link = 'logit'),
control = glmmTMBControl(optCtrl=list(iter.max=1e3,eval.max=1e3)))
fit_ar1 = glmmTMB(Sc_Phyto ~ Treat*Rate*Season*WAT + ar1(WAT-1|ID),
data = data2,
family = ordbeta(link = 'logit'),
control = glmmTMBControl(optCtrl=list(iter.max=1e3,eval.max=1e3)))
#| warning: false
#| message: false
# Load packages
library(tidyverse)
library(glmmTMB)
library(DHARMa)
library(ggResidpanel)
library(emmeans)
library(multcomp)
# Set global options
my_palette = c('steelblue', 'sienna', 'goldenrod', 'olivedrab', 'thistle', 'tan')
options(contrasts = c('contr.sum', 'contr.poly'),
dplyr.width = Inf,                 # Always print all columns
pillar.print_max = 100,            # Don't print more than 100 rows
pillar.print_min = 100,
ggplot2.discrete.colour = my_palette,
ggplot2.discrete.fill = my_palette)
my_theme = theme_classic()+
theme(text = element_text(size = 12))
theme_set(my_theme)
#| warning: false
#| message: false
# Load packages
library(tidyverse)
library(glmmTMB)
library(DHARMa)
library(ggResidpanel)
library(emmeans)
library(multcomp)
# Set global options
my_palette = c('steelblue', 'sienna', 'goldenrod', 'olivedrab', 'thistle', 'tan')
options(contrasts = c('contr.sum', 'contr.poly'),
dplyr.width = Inf,                 # Always print all columns
pillar.print_max = 100,            # Don't print more than 100 rows
pillar.print_min = 100,
ggplot2.discrete.colour = my_palette,
ggplot2.discrete.fill = my_palette)
my_theme = theme_classic()+
theme(text = element_text(size = 12))
theme_set(my_theme)
data = read.csv("All_RUN_12pm_30m_cal.csv", header = T) %>%
rename(WAT = 1) |>
mutate(Rate_Metric = round(oz.A*0.0700531973 , 2)) %>%   #convert oz/a to kg/hectares
mutate(Control = ifelse(Treat == "Untreated Control", "C", "T")) %>%
mutate(Rate_Metric = ifelse(is.na(Rate_Metric), " ", paste(Rate_Metric, "kg/ha"))) %>% #take out NA values and create treatment Names
filter(Treat != "1/2 Fert Control") %>%
mutate(uPhyto = Phyto) %>%
mutate(Phyto = asin(sqrt(Phyto/100))) %>%
#make factors
mutate(Season = as.factor(Season))%>%
mutate(Rate = as.factor(Rate)) %>%
mutate(Treat = as.factor(Treat)) %>%
mutate(WAT = as.factor(WAT)) %>%
mutate(Mode_Action = ifelse(Treat == "Florpyrauxifen-benzyl" | Treat == "2,4-D", "Auxin Mimic", ifelse(Treat == "Penoxsulam" | Treat == "Glyphosate", "Amino Acid Inhibitor", ifelse(Treat == "Diquat" | Treat == "Carfentrazone", "Contact", "Control")))) %>% #add mode of Action Column
mutate(Treat_Name = paste(Treat, Rate_Metric)) %>%
#add VI columns
mutate(TGI = G - .39*R - .61*B) %>%
mutate(VARI = (G - R)/(G+R-B)) %>%
mutate(EXGI = 2*G - R - B) %>%
mutate(MGRVI = (G^2 - R^2)/(G^2+R^2)) %>%
mutate(RGBVI = (G^2 - R*B)/ (G^2+R*B)) %>%
mutate(GLI = (2*G - R - B)/(2*G+R+B)) %>%
mutate(MPRI = (G-R)/ (G+R)) %>%
mutate(CRI = (1/B)-(1/G)) %>%
mutate(EXGR = EXGI - 1.4*R - G)
(data)
#making data in long form
vis <- c("TGI", "VARI", "EXGI", "MGRVI", "RGBVI", "GLI", "MPRI", "CRI", "EXGR")
datlng <- data %>%
pivot_longer(cols = vis, names_to = "VI", values_to = "value")
# Remove data from untreated control. Also, for later, create proportion version of
# phytotoxicity and fix rate levels
set = data |>
filter(Treat != 'Untreated Control') |>
mutate(Sc_Phyto = uPhyto/100,
Rate = factor(Rate, levels = c('L', 'H'),
labels = c('Low', 'High'))) |>
droplevels()
# Use cor function on all the VI columns
sapply(set[, vis], FUN = cor, y = set$uPhyto, method = 'kendall')
null_fit = glmmTMB(Sc_Phyto ~ 1, data = set,
family = ordbeta(link = 'logit'))
AIC(null_fit,
update(null_fit, formula. = Sc_Phyto ~ TGI),
update(null_fit, formula. = Sc_Phyto ~ VARI),
update(null_fit, formula. = Sc_Phyto ~ EXGI),
update(null_fit, formula. = Sc_Phyto ~ MGRVI),
update(null_fit, formula. = Sc_Phyto ~ RGBVI),
update(null_fit, formula. = Sc_Phyto ~ GLI),
update(null_fit, formula. = Sc_Phyto ~ MPRI),
update(null_fit, formula. = Sc_Phyto ~ CRI),   # CRI is still best
update(null_fit, formula. = Sc_Phyto ~ EXGR))
fit = glmmTMB(Sc_Phyto ~ CRI, data = set, family = ordbeta(link = 'logit'))
emm = emmeans(fit, ~ CRI, type = 'response',
at = list(CRI = seq(min(set$CRI), max(set$CRI), diff(range(set$CRI))/100)))
emm |>
as.data.frame() |>
ggplot(aes(x = CRI))+
geom_ribbon(aes(ymin = asymp.LCL, ymax = asymp.UCL), alpha = .25)+
geom_line(aes(y = response))+
geom_point(aes(y = Sc_Phyto), data = set)
fit = glmmTMB(Sc_Phyto ~ CRI/Treat, data = set, family = ordbeta(link = 'logit'))
emm = emmeans(fit, ~ CRI|Treat, type = 'response', cov.keep = T,
at = expand.grid(CRI = seq(min(set$CRI), max(set$CRI), diff(range(set$CRI))/100)))
emm |>
as.data.frame() |>
ggplot(aes(x = CRI, color = Treat, fill = Treat))+
facet_wrap(~ Treat)+
geom_ribbon(aes(ymin = asymp.LCL, ymax = asymp.UCL), alpha = .25, color = NA)+
geom_line(aes(y = response))+
geom_point(aes(y = Sc_Phyto), data = set)
fit = glmmTMB(Sc_Phyto ~ CRI/Treat + (CRI-1|WAT), data = set, family = ordbeta(link = 'logit'))
install.packages("glmmTMB")
install.packages("glmmTMB")
install.packages("Matrix")
install.packages("Matrix")
install.packages("Matrix")
install.packages("Matrix")
install.package("TMB", type = "source")
install.packages("TMB", type = "source")
install.packages("TMB", type = "source")
library(tidyverse)
library(gt)
library(SciViews)
library(broom)
#broom is just to get values form lm function in easier to reference from
library(glue)
library(ggtext)
#glue and ggtext are for making labels. trying to make labels and get default ggplot functions to correctly parse those labels is a nightmare. ggtext helps by allowing you to use html tags in the labels. glue helps by allowing you to use variables in the labels.
library(readxl)
library(tinytex)
#tinytex::install_tinytex()
#tinytex::tlmgr_update()
setwd("C:/Users/amber.riner/Documents/LWreports")
### Loading and Preparing Data
data_1 = read_xlsx("Lakewatch Base File 10-24-2023.xlsx")
data_1 <- data_1 %>%
mutate(Lake_County = paste(Lake, County)) %>%
filter(Study == "LW") %>%
filter(`water type` == "Lake" | `water type` == "RiverStream" | `water type` == "Estuary")
head(data_1)
data_2 = read.csv("All_Data.csv")
data_2 = data_2 %>%
mutate(Station = as.character(Station)) %>%
mutate(Lake_County = paste(Lake, County))
head(data_2)
#data_all <- data_1 %>% full_join(data_2, by = c("Lake_County", "Station"))
#Lakes = unique(data_1$Lake_County)
Lakes = c("Alice Alachua", "Bivans Arm Alachua")
print(Lakes)
n = 1
N = length(Lakes)
### for loop with counter ###
for(l in Lakes){
#subsets data for lake of interest
Lake_1 <- data_1 %>%
filter(Lake_County == l)
Lake_2 <- data_2 %>%
filter(Lake_County == l)
file_name = paste(Lake_2[1], ".pdf")
gmean <- function(x){
xc <- x[!is.na(x)]
xg <- exp(mean(log(xc[xc>0])))
xg <- round(xg)
return(xg)
}
#adding a column using if/else for lake classification
##this code currently has no fallback for if the data is missing.
Lake_2 = Lake_2 %>% mutate(lake_class = ifelse(
gmean(`Color`) > 40, "Colored", ifelse(
gmean(`Color`) <= 40 & gmean(`Cond_uS`) <= 20, "Clear Soft Water","Clear Hard Water")))
#adding a column using if/else for trophic state
Lake_2 = Lake_2 %>% mutate(trophic_state = ifelse(
gmean(CHL) < 3, "Oligotrophic", ifelse(
gmean(CHL) >= 3 & gmean(CHL) < 7, "Mesotrophic", ifelse(
gmean(CHL) >= 7 & gmean(CHL) < 40, "Eutrophic", "Hypereutrophic"))))
###change Test.RMD to "LW Markdown Code Lake.RMD"
rmarkdown::render(input = "LWReport Markdown Code Lake.Rmd", output_format = "pdf_document",         # 2. Establish the format
output_file = paste0(l ,"_report.pdf"), # 3. Define the output file name
output_dir = "Lake",                       # 4. Define an output folder/directory
params = list(Lakes = l))
########################################################
#counter
print(Lake_2$Lake_County[1])
print(paste(n, "/", N))
n <- n+1
}
library(tidyverse)
library(gt)
library(SciViews)
library(broom)
#broom is just to get values form lm function in easier to reference from
library(glue)
library(ggtext)
#glue and ggtext are for making labels. trying to make labels and get default ggplot functions to correctly parse those labels is a nightmare. ggtext helps by allowing you to use html tags in the labels. glue helps by allowing you to use variables in the labels.
library(readxl)
library(tinytex)
#tinytex::install_tinytex()
#tinytex::tlmgr_update()
setwd("C:/Users/amber.riner/Documents/LWreports")
### Loading and Preparing Data
data_1 = read_xlsx("Lakewatch Base File 10-24-2023.xlsx")
data_1 <- data_1 %>%
mutate(Lake_County = paste(Lake, County)) %>%
filter(Study == "LW") %>%
filter(`water type` == "Lake" | `water type` == "RiverStream" | `water type` == "Estuary")
head(data_1)
data_2 = read.csv("All_Data.csv")
data_2 = data_2 %>%
mutate(Station = as.character(Station)) %>%
mutate(Lake_County = paste(Lake, County))
head(data_2)
#data_all <- data_1 %>% full_join(data_2, by = c("Lake_County", "Station"))
#Lakes = unique(data_1$Lake_County)
Lakes = c("Alice Alachua", "Bivans Arm Alachua")
print(Lakes)
n = 1
N = length(Lakes)
### for loop with counter ###
for(l in Lakes){
#subsets data for lake of interest
Lake_1 <- data_1 %>%
filter(Lake_County == l)
Lake_2 <- data_2 %>%
filter(Lake_County == l)
file_name = paste(Lake_2[1], ".pdf")
gmean <- function(x){
xc <- x[!is.na(x)]
xg <- exp(mean(log(xc[xc>0])))
xg <- round(xg)
return(xg)
}
#adding a column using if/else for lake classification
##this code currently has no fallback for if the data is missing.
Lake_2 = Lake_2 %>% mutate(lake_class = ifelse(
gmean(`Color`) > 40, "Colored", ifelse(
gmean(`Color`) <= 40 & gmean(`Cond_uS`) <= 20, "Clear Soft Water","Clear Hard Water")))
#adding a column using if/else for trophic state
Lake_2 = Lake_2 %>% mutate(trophic_state = ifelse(
gmean(CHL) < 3, "Oligotrophic", ifelse(
gmean(CHL) >= 3 & gmean(CHL) < 7, "Mesotrophic", ifelse(
gmean(CHL) >= 7 & gmean(CHL) < 40, "Eutrophic", "Hypereutrophic"))))
###change Test.RMD to "LW Markdown Code Lake.RMD"
rmarkdown::render(input = "LWReport Markdown Code Lake.Rmd", output_format = "pdf_document",         # 2. Establish the format
output_file = paste0(l ,"_report.pdf"), # 3. Define the output file name
output_dir = "Lake",                       # 4. Define an output folder/directory
params = list(Lakes = l))
########################################################
#counter
print(Lake_2$Lake_County[1])
print(paste(n, "/", N))
n <- n+1
}
for(l in Lakes){
#subsets data for lake of interest
Lake_1 <- data_1 %>%
filter(Lake_County == l)
Lake_2 <- data_2 %>%
filter(Lake_County == l)
file_name = paste(Lake_2[1], ".pdf")
gmean <- function(x){
xc <- x[!is.na(x)]
xg <- exp(mean(log(xc[xc>0])))
xg <- round(xg)
return(xg)
}
#adding a column using if/else for lake classification
##this code currently has no fallback for if the data is missing.
Lake_2 = Lake_2 %>% mutate(lake_class = ifelse(
gmean(`Color`) > 40, "Colored", ifelse(
gmean(`Color`) <= 40 & gmean(`Cond_uS`) <= 20, "Clear Soft Water","Clear Hard Water")))
#adding a column using if/else for trophic state
Lake_2 = Lake_2 %>% mutate(trophic_state = ifelse(
gmean(CHL) < 3, "Oligotrophic", ifelse(
gmean(CHL) >= 3 & gmean(CHL) < 7, "Mesotrophic", ifelse(
gmean(CHL) >= 7 & gmean(CHL) < 40, "Eutrophic", "Hypereutrophic"))))
###change Test.RMD to "LW Markdown Code Lake.RMD"
rmarkdown::render(input = "LWReport Markdown Code Lake.Rmd", output_format = "pdf_document",         # 2. Establish the format
output_file = paste0(l ,"_report.pdf"), # 3. Define the output file name
output_dir = "output",                       # 4. Define an output folder/directory
params = list(Lakes = l))
########################################################
#counter
print(Lake_2$Lake_County[1])
print(paste(n, "/", N))
n <- n+1
}
for(l in Lakes){
#subsets data for lake of interest
Lake_1 <- data_1 %>%
filter(Lake_County == l)
Lake_2 <- data_2 %>%
filter(Lake_County == l)
file_name = paste(Lake_2[1], ".pdf")
gmean <- function(x){
xc <- x[!is.na(x)]
xg <- exp(mean(log(xc[xc>0])))
xg <- round(xg)
return(xg)
}
#adding a column using if/else for lake classification
##this code currently has no fallback for if the data is missing.
Lake_2 = Lake_2 %>% mutate(lake_class = ifelse(
gmean(`Color`) > 40, "Colored", ifelse(
gmean(`Color`) <= 40 & gmean(`Cond_uS`) <= 20, "Clear Soft Water","Clear Hard Water")))
#adding a column using if/else for trophic state
Lake_2 = Lake_2 %>% mutate(trophic_state = ifelse(
gmean(CHL) < 3, "Oligotrophic", ifelse(
gmean(CHL) >= 3 & gmean(CHL) < 7, "Mesotrophic", ifelse(
gmean(CHL) >= 7 & gmean(CHL) < 40, "Eutrophic", "Hypereutrophic"))))
###change Test.RMD to "LW Markdown Code Lake.RMD"
rmarkdown::render(input = "LWReport Markdown Code Lake.Rmd", output_format = "pdf_document",         # 2. Establish the format
output_file = paste0(l ,"_report.pdf"), # 3. Define the output file name
output_dir = "Lake",                       # 4. Define an output folder/directory
params = list(Lakes = l))
########################################################
#counter
print(Lake_2$Lake_County[1])
print(paste(n, "/", N))
n <- n+1
}
for(l in Lakes){
#subsets data for lake of interest
Lake_1 <- data_1 %>%
filter(Lake_County == l)
Lake_2 <- data_2 %>%
filter(Lake_County == l)
file_name = paste(Lake_2[1], ".pdf")
gmean <- function(x){
xc <- x[!is.na(x)]
xg <- exp(mean(log(xc[xc>0])))
xg <- round(xg)
return(xg)
}
#adding a column using if/else for lake classification
##this code currently has no fallback for if the data is missing.
Lake_2 = Lake_2 %>% mutate(lake_class = ifelse(
gmean(`Color`) > 40, "Colored", ifelse(
gmean(`Color`) <= 40 & gmean(`Cond_uS`) <= 20, "Clear Soft Water","Clear Hard Water")))
#adding a column using if/else for trophic state
Lake_2 = Lake_2 %>% mutate(trophic_state = ifelse(
gmean(CHL) < 3, "Oligotrophic", ifelse(
gmean(CHL) >= 3 & gmean(CHL) < 7, "Mesotrophic", ifelse(
gmean(CHL) >= 7 & gmean(CHL) < 40, "Eutrophic", "Hypereutrophic"))))
if(Lake_1$`water type`[1] == "Lake") {
###change Test.RMD to "LWReport Markdown Code Lake.Rmd"
rmarkdown::render(input = "LWReport Markdown Code Lake.Rmd", output_format = "pdf_document",         # 2. Establish the format
output_file = paste0(l ,"_report.pdf"), # 3. Define the output file name
output_dir = "Lake",                       # 4. Define an output folder/directory
params = list(Lakes = l))  }
if(Lake_1$`water type`[1] == "Estuary") {
rmarkdown::render(input = "LWReport Markdown Code Estuary.Rmd", output_format = "pdf_document",         # 2. Establish the format
output_file = paste0(l ,"_report.pdf"), # 3. Define the output file name
output_dir = "Estuary",                       # 4. Define an output folder/directory
params = list(Lakes = l))  }
if(Lake_1$`water type`[1] == "RiverStream") {
rmarkdown::render(input = "LWReport Markdown Code RiverStream.Rmd", output_format = "pdf_document",         # 2. Establish the format
output_file = paste0(l ,"_report.pdf"), # 3. Define the output file name
output_dir = "RiverStream",                       # 4. Define an output folder/directory
params = list(Lakes = l))  }
########################################################
#counter
print(Lake_2$Lake_County[1])
print(paste(n, "/", N))
n <- n+1
}
